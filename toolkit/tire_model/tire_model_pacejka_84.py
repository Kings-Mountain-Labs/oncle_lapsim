from typing import List
from math import sin, atan, pi

def clamp(x: float):
    return max(min(x, 1), 0)
class TireModel:
    def __init__(self, a: List[float], b: List[float], surface:float = 1.0, H:float = 0, V:float = 0) -> None:
        """
        Coefficient values for tire are obtained through tire parser 

        :param p1: c(1) = a1... Longitudinal coefficients
        :param p2: c(1) = b1... Lateral coefficients
        :param p3: Track surface scaling factor
        :param p4: H
        :param p5: V
        """

        self.V = V
        self.H = H
        self.b0 = b[0]
        self.b1 = b[1]
        self.b2 = b[2]
        self.b3 = b[3]
        self.b4 = b[4]
        self.b8 = b[5]

        self.a0 = a[0]
        self.a1 = a[1]
        self.a2 = a[2]
        self.a3 = a[3]
        self.a4 = a[4]
        self.a7 = a[5]

        self.Ca = self.a0
        self.Ea = self.a7
        self.Cb = self.b0
        self.Eb = self.b8
        self.surface = surface # surface normalization coefficient

    def solve_for_long_force(self, force_z: float, SL: float, mu:float) -> float:
        """
        Generates the longitudinal force (FX) generated by tire for a given z force and SL

        RCVD Traction Circle (Fig. 2.31) used as reference for sign convention
        where Positive SL is braking and Negative SL is accelerating

        :param p1: Force in Z on the Tire
        :param p2: SL is in percentage
        :return: Lateral Force generated by the Tire
        """
        f_z, s_l = force_z * -1, clamp(SL)*-1
        d = (self.b1*f_z+self.b2)*f_z
        bcd = (self.b3*f_z**2+self.b4*f_z)
        b = bcd/(self.Ca*d)
        Bx1 = b*(s_l+self.H)

        return mu*self.surface*d*sin(self.Ca*atan(Bx1-self.Ea*(Bx1-atan(Bx1))))+self.V

    def solve_for_lat_force(self, force_z: float, slip_angle: float, mu:float) -> float:
        """
        Generates the lateral force (FY) generated by tire for a given z force and Slip Angle

        RCVD Traction Circle (Fig. 2.31) used as reference for sign convention
        where Positive SA is right turn and produces Positive FY and Negative SL
        is left turn and produces Negative FY.

        :param p1: Force in Z on the Tire
        :param p2: Slip Angle in Degrees
        :return: Lateral Force generated by the Tire
        """
        f_z, s_a = force_z * -1, slip_angle*pi/180*-1

        d = (self.a1*f_z+self.a2)*f_z
        bcd = self.a3*sin(atan(f_z/self.a4)*2)
        b = bcd/(self.Ca*d)
        Bx1 = b*(s_a+self.H)

        return mu*self.surface*(d*sin(self.Ca*atan(Bx1-self.Ea*(Bx1-atan(Bx1))))+self.V)


def get_H18x75R25B7() -> TireModel:
    """
    Hoosier 18" DIA 7.5" Width R25B 7
    """
    a = [0.937428323741559,1.074964251315230e-04,3.156308346539219,8.401973852188474e+03,3.000265556862718e+02,0.246024018437227]
    b = [9.024117283527670e-04,-2.000000000004689,2.999999993293833e+03,-6.381207727102746e-04,-0.564754663496273,1.061795649571943]
    return TireModel(a, b)
    


if __name__ == '__main__':
    import matplotlib.pyplot as plt

    tyre_model = get_H18x75R25B7()
    print(tyre_model.solve_for_long_force(20, 3))
    