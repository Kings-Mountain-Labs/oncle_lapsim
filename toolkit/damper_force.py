import numpy as np
import scipy.io as sio
from scipy.interpolate import interp1d
from loading_util import make_path

def clamp_int(n: int, minn: int, maxn: int) -> int:
    """
    Clamps int within the range of two ints

    :param n: int to be clamped
    :param minn: lower limit
    :param maxn: upper limit
    :return: Clamped int
    """
    return max(min(maxn, n), minn)

class DamperForce:
    def __init__(self, LSCset: int, LSRset: int, HSCset: int, HSRset: int) -> None:
        """
        Creates Damper Force Object

        :param LSCset: Low Speed Compression (in clicks up to 24)
        :param LSRset: Low Speed Rebound (in clicks up to 24)
        :param HSCset: High Speed Compression (in half turns up to 10)
        :param HSRset: High Speed Rebound (in half turns up to 10)
        """
        self.LSCset = clamp_int((LSCset - 1), 1, 24)
        self.LSRset = clamp_int((LSRset - 1), 1, 24)
        self.HSCset = clamp_int((HSCset - 1), 1, 10)
        self.HSRset = clamp_int((HSRset - 1), 1, 10)
        self.load_damper_profiles()
        self.find_switch_speeds()
        self.V = np.arange(14)

    def load_damper_profiles(self):
        if self.LSRset<=8 & self.HSRset<=3:
            self.HSR = sio.loadmat(make_path('./Data/Dampers/Softs/softHSR.mat'))['RC']
            self.LSR = sio.loadmat(make_path('./Data/Dampers/Softs/softLSR.mat'))['RC']
        elif self.LSRset>=17 & self.HSRset>=8:
            self.HSR = sio.loadmat(make_path('./Data/Dampers/Tights/tightHSR.mat'))['RC']
            self.LSR = sio.loadmat(make_path('./Data/Dampers/Tights/tightLSR.mat'))['RC']
        else:
            self.HSR = sio.loadmat(make_path('./Data/Dampers/Mids/midHSR.mat'))['RC']
            self.LSR = sio.loadmat(make_path('./Data/Dampers/Mids/midLSR.mat'))['RC']

        if self.LSCset<=8 & self.HSCset<=3:
            self.HSC = sio.loadmat(make_path('./Data/Dampers/Softs/softHSC.mat'))['CC']
            self.LSC = sio.loadmat(make_path('./Data/Dampers/Softs/softLSC.mat'))['CC']
        elif self.LSCset>=17 & self.HSCset>=8:
            self.HSC = sio.loadmat(make_path('./Data/Dampers/Tights/tightHSC.mat'))['CC']
            self.LSC = sio.loadmat(make_path('./Data/Dampers/Tights/tightLSC.mat'))['CC']
        else:
            self.HSC = sio.loadmat(make_path('./Data/Dampers/Mids/midHSC.mat'))['CC']
            self.LSC = sio.loadmat(make_path('./Data/Dampers/Mids/midLSC.mat'))['CC']

    def find_switch_speeds(self):
        """
        finds compression and rebound crossover speeds by finding the average value between the high speed and low speed LUT at the point with the highest gradient
        """
        self.CXS = (self.HSC[np.argmax(np.abs(np.gradient(self.HSC[:, self.HSCset]))), self.HSCset] + self.LSC[np.argmax(np.abs(np.gradient(self.LSC[:, self.LSCset]))), self.LSCset])/2
        self.RXS = (self.HSR[np.argmax(np.abs(np.gradient(self.HSR[:, self.HSRset]))), self.HSRset] + self.LSR[np.argmax(np.abs(np.gradient(self.LSR[:, self.LSRset]))), self.LSRset])/2

    def solve_for_speed(self, speed: float) -> float:
        """
        Generates the force generated by the damper at a given speed

        :param p1: speed  (of suspension travel in/s, positive = wheel traveling upwards)
        :return: Force of dampers on wheel (positive = acting downwards)
        """
        if speed > 0:
            if speed > self.CXS:
                return interp1d(self.V, self.HSC[:, self.HSCset])(speed)
            else:
                return interp1d(self.V, self.LSC[:, self.LSCset])(speed)
        elif speed < 0:
            if speed > self.RXS:
                return interp1d(self.V, self.HSR[:, self.HSRset])(-speed)
            else:
                return interp1d(self.V, self.LSR[:, self.LSRset])(-speed)
        else:
            return 0

if __name__ == '__main__':
    import matplotlib.pyplot as plt

    damp = DamperForce(12, 12, 1, 1)
    print(damp.solve_for_speed(1))
    plt.imshow(damp.LSC, cmap='hot', interpolation='nearest')
    plt.show()
